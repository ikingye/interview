<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>7. 云计算 on 面试笔记</title>
    <link>https://ikingye.github.io/interview/docs/cloud/</link>
    <description>Recent content in 7. 云计算 on 面试笔记</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://ikingye.github.io/interview/docs/cloud/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker</title>
      <link>https://ikingye.github.io/interview/docs/cloud/docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/interview/docs/cloud/docker/</guid>
      <description>Docker #  更多内容见：Docker 学习笔记
entrypoint vs cmd #    格式
 Shell form  实际运行的是 /bin/sh -c 命令  有些镜像没有 shell 程序，无法使用这种方式 从外部发送任何 POSIX 信号到 docker 容器，/bin/sh 命令不会转发消息给实际运行的命令   CMD executable param1 param2 ENTRYPOINT executable param1 param2  会忽略 CMD 或者 docker run 参数 无法覆盖     Exec form  the JSON array format CMD [&amp;quot;executable&amp;quot;,&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]  如果要使用 Shell 环境变量，必须显示使用 sh 如 CMD [ &amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo $HOME&amp;quot; ]   ENTRYPOINT [&amp;quot;executable&amp;quot;,&amp;quot;param1&amp;quot;,&amp;quot;param2&amp;quot;]  会把 CMD 接到后面作为参数 docker run 可以覆盖：docker run demo --entrypoint cmd   不管是 ENTRYPOINT 还是 CMD 命令，都强烈建议采用 exec 表示法      覆盖</description>
    </item>
    
    <item>
      <title>Kubernetes</title>
      <link>https://ikingye.github.io/interview/docs/cloud/kubernetes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/interview/docs/cloud/kubernetes/</guid>
      <description>Kubernetes #  更多内容见：Kubernetes 学习笔记
参考：
 Kubernetes API 资源使用 - 应该使用哪个 Group 和 Version?  端口 #   containerPort：在容器上，用于被 pod 绑定，是可选的，仅仅是提示信息，容器中任何监听 0.0.0.0 的端口，都会暴露出来  是可选的，仅仅是提示信息 容器中任何监听 0.0.0.0 的端口，都会暴露出来 无法被更新    targetPort：在 pod 上，从 port 和 nodePort 上来的流量，经过 kube-proxy 流入到后端 pod 的 targetPort 上，最后进入容器  targetPort 和 containerPort 是一致的  targetPort and containerPort must be identical most of the time because whatever port is open for your application in a container that would be the same port you will wish to send traffic from service via targetPort.</description>
    </item>
    
    <item>
      <title>Cloud Native</title>
      <link>https://ikingye.github.io/interview/docs/cloud/native/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/interview/docs/cloud/native/</guid>
      <description>Cloud Native #  </description>
    </item>
    
  </channel>
</rss>
